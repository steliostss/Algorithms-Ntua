## <u>Αλγόριθμοι και πολυπλοκότητα: 4η σειρά γραπτών ασκήσεων</u>

-----

**<u>Ονοματεπώνυμο:</u>** Τσαγκαράκης Στυλιανός **<u>ΑΜ:</u>** 03115180

---

### <u>Άσκηση 1: Προτάσεις Φίλων</u>  

Για κάθε j και κάθε μονοπάτι p από το i σε αυτό, θέλουμε να βρούμε το μέγιστο $t(p) = \prod_{q=0}^{q=l-1} {t(q,q+1)}$. Δηλαδή το μέγιστο $\log t(p) = \sum_{q=0}^{q=l-1} {\log t(q,q+1)}$, δηλαδή το ελάχιστο $-\log t(p) = \sum_{q=0}^{q=l-1} \log \frac {1}{t(q,q+1)}$. Άρα μετασχηματίζουμε το πρόβλημα σε ένα γράφημα όλων των n ατόμων και θέτουμε το βάρος κάθε ακμής $e=(u,v)$ το $w(u,v) = \log \frac {1} {t(u,v)}$ (θετικό αφού $t(u,v) \in (0,1)$) και δεν έχουμε καμία ακμή αν $t(u,v) = 0$. 
Άρα αναζητάμε τα συντομότερα μονοπάτια από το i προς κάθε j μήκους $l \leq k$, που να έχουν συνολικό βάρος $\leq \log \frac {1}{\beta_l}$. 
O **Bellman-Ford** σε μορφή δυναμικού προγραμματισμού υπολογίζει το συντομότερο μονοπάτι από την αρχική στον u με το πολύ r ακμές $D[u,r] = \min \{ D[u, r-1], \min_{v:(v,u)\in E} \{ D[v,r-1]\}+w(v,u) \}$.
Ο παραπάνω αλγόριθμος τρέχει για k επαναλήψεις. Αυτό που μας επιτρέπει να πάρουμε σωστά αποτελέσματα είναι ότι κάθε επανάληψη βασίζεται στις προηγούμενες τιμές ώστε να εξασφαλίζουμε ότι το μονοπατι που υπολογίζουμε δεν ξεπερνά το δείκτη της επανάληψης.
Φυσικά κάθε φορά που ανανεώνουμε μια απόσταση $D[u,r]$ εξετάζουμε αν είναι $\leq \log {\frac {1}{\beta_r}}$ και μόνο τότε την αποθηκεύουμε ως καλή πρόταση.  Όταν ανανεθεί, τότε πράγματι το μήκος του μονοπατιού θα είναι r γιατί αν ήταν μικρότερο θα το είχαμε βρεί σε προηγούμενη επενάληψη και δε θα το ανανεώναμε.
Στο τέλος έχουμε ελέγξει όλα τα δυνατά συντομότερα μονοπάτια με $l \leq k​$ μήκος προς κάθε κόμβο j και έχουμε βρεί τις καλές προτάσεις φίλων.

**Πολυπλοκότητα:** 

- Η αρχικοπόηση όλων των αποστάσεων $D[u,0]$ γίνεται σε $O(n)$.
- Σε κάθε επανάληψη, εξετάζουμε όλες τις ακμές από μια φορά (για κάθε κόμβο όλες τις γειτονικές του) και κάνουμε σταθερό αριθμό συγκρίσεων σε $Ο(m)$. Οι επαναλήψεις είναι συνολικά k άρα το δεύτερο μέρος γίνεται σε $Ο(km)$.

Επομένως έχουμε συνολικη πολυπλοκότητα: $O(n + km)$.

### <u>Άσκηση 2: Τροποποίηση του Αλγόριθμου Dijkstra (DPV 4.17)</u>  

#### (α) 

Εστω ο αλγόριθμος Dijkstra όπως υφίσταται χωρίς τροποποιήσεις. Έχουμε ένα απλό πίνακα D, n θέσεων, όπου υπάρχουν οι εκτιμήσεις των αποστάσεων κάθε κόμβου ανά πάσα στιγμή. Τροποποιούμε τον αλγόριθμο ώστε αντί να έχουμε ουρά προτεραιότητας να έχουμε έναν πίνακα Α (επιπλέον του D), μεγέθους nC. Κάθε στοιχείο του Α είναι μια λίστα κόμβων του γραφήματος.

Για παράδειγμα αν υπάρχει στη θέση 4 του πίνακα A μία λίστα με τους αριθμούς 2 και 3, σημαίνει ότι οι κόμβοι 2 και 3 έχουν εκτίμηση απόστασης 4 (τη δεδομένη στιγμή) απ ́ τον αρχικό μας κόμβο. Διαφορετικά, αν υπάρχει NULL, σημαίνει ότι δεν υπάρχει κόμβος με εκτίμηση απόστασης 4 από τον αρχικό.

Αρχικοποίηση: Ορίζουμε ένα δείκτη (index) του πίνακα A με όνομα minidx που αρχικά δείχνει στο A[0]. Στη θέση αυτή δημιουργούμε μία λίστα με μοναδικό στοιχείο (αρχικά) τον κόμβο s. Επίσης, υπάρχει λίστα όλων των υπολοίπων κόμβων στο A[nC − 1].

Η εύρεση ελαχίστου γίνεται γραμμικά απ ́ τη θέση που δείχνει ο minidx και προχωρώντας τον, μέχρι να βρούμε μία μη κενή λίστα κόμβων στον A. **Θέτουμε ως u έναν απ ́ τους κόμβους της λίστας αυτής και τον αφαιρούμε από τη λίστα υλοποιώντας Dijkstra**. Στην επόμενη επανάληψη ο minidx ξεκινάει από εκεί που έμεινε. Αν κάπου ο minidx ξεπεράσει το στοιχείο A[nC − 1], τερματίζει ο αλγόριθμος.

Στο στάδιο της αναπροσαρμογής μεταφέρουμε τον κόμβο απ ́τη λίστα που αντιστοιχεί στην προηγούμενη εκτίμηση, στη λίστα με τη νέα εκτίμηση, στον πίνακα A. Συνολικά, O(m). Για την εύρεση του ελαχίστου χρησιμοποιούμε το δείκτη minidx ο οποίος ποτέ δεν επιστρέφει πίσω γιατί ο Dijkstra εξετάζει σε όλο και μεγαλύτερες αποστάσεις.  ́Ετσι, σε όλη τη διάρκεια εκτέλεσης του αλγορίθμου, ο minidx διατρέχει ολόκληρο τον πίνακα A ακριβώς μία φορά (δηλαδή nC βήματα). 

Έτσι, συνολική πολυπλοκότητα: $O(nC + m)$.

#### (β)

Δεν αλλάζουμε καθόλου την υλοποίηση που υπάρχει στις διαφάνειες και χρησιμοποιούμε Δυαδικό Σωρό (Binary Heap). Ισχυριζόμαστε ότι η ουρά προτεραιότητας έχει μέγιστη διαφορά εκτιμώμενης απόστασης $d_{max} − d_{min} = 2^C$ .  Άρα η εύρεση μεγίστου στο σωρό και η αναδιοργάνωσή του δε χρειάζονται $\log n$ στη
χειρότερη περίπτωση, αλλά $log(d_{max} − d_{min} ) = \log 2^C = C$.

Έτσι η συνολική πολυπλοκότητα θα είναι $O((n+m)C)$. Αποδεικνύεται με επαγωγή.

### <u>Άσκηση 3: Συντομότερα Μονοπάτια με Δύο Κριτήρια</u>  





### <u>Άσκηση 4: Διαφημίσεις στο Διαδίκτυο</u>  





### <u>Άσκηση 5: Αναγωγές και ΝΡ-Πληρότητα</u>  

