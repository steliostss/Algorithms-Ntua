## <u>Αλγόριθμοι και πολυπλοκότητα: 2η σειρά γραπτών ασκήσεων</u>

-----

**<u>Ονοματεπώνυμο:</u>** Τσαγκαράκης Στυλιανός **<u>ΑΜ:</u>** 03115180

---

### <u>Άσκηση 1: Μακρύτερο μονοπάτι σε δέντρο</u>  

Έστω δέντρο $T(V,E)$ και το βάρος κάθε κορυφής $w(u) \in \Z$. 

Ο αλγόριθμος για να υπολογιστεί το μακρύτερο μονοπάτι που ζητάμε έχει ως εξής: 
Ξεκινάμε από τη ρίζα και εκτελώντας αναδρομικά σε κάθε παιδί τον ίδιο αλγόριθμο. Κάθε φορά που βρίσκουμε μεγαλύτερο μονοπάτι το κρατάμε.
Στον πατέρα επιστρέφεται το μεγαλύτερο μονοπάτι που μπορεί να σχηματιστεί αν το παιδί ήταν η αρχή αυτού το μονοπατιού. Ο πατέρας κρατάει από όλα τα παιδιά του τα 2 μεγαλύτερα μονοπάτια που του γυρνάνε και συγκρίνει το μονοπάτι που δημιουργείται αν ήταν μέσο αυτού  με ένα γενικότερο μονοπάτι που κρατάμε πάντα το μέγιστο.

Παρακάτω και ψευδοκώδικας:  

```c
max_path = 0

main
    max_path = longest(root_of_tree)
    print(max_path)

longest(node k)
    max1 = 0
	max2 = 0
	for all kids n of k
    	temp = longest(n)
		if temp > max1
			max2 = max1
			max1 = temp
		else if max2 < temp
			max2 = temp
	val = k.value + max1 + max2 
	if val > max_path
		max_path = val
    return k.value + max1
```

**Πολυπλοκότητα:** Γραμμική, $Ο(V+E)$, αφού επισκεπτόμαστε κάθε κόμβο και κάθε ακμή μόνο μια φορά.
**Ορθότητα:** 
Έστω $ε = R+\pi_j + \pi_i$ το μονοπάτι που έχει βρει ως βέλτιστο ο αλγόριθμός μας ($C$). Με $\pi_j \leq \pi_i$
Έστω $ε΄$ το μονοπάτι που έχει βρει ένας άλλος βέλτιστος αλγόριθμος ($C^*$)
Υπάρχουν οι εξής περιπτώσεις:

- Το $ε΄$ να περνάει από το R. Έστω $ε΄ = R + \pi_j'+ \pi_i'$ με $\pi_j' \leq \pi_i'$. Ο $C^*$ βρίσκει καλύτερο μονοπάτι αν $\pi_j + \pi_i \leq \pi_j' + \pi_i'$. Όμως ο αλγόριθμός μας επιλέγει πάντα τα 2 μεγαλύτερα μονοπάτια άρα $\pi_j \geq \pi_j'$ και  $\pi_i \geq \pi_i'$. Άρα δεν βρίσκει καλύτερο μονοπάτι (άτοπο).
- Το $ε΄$ να μην περνάει από το R αλλά να περνάει από ένα παιδί η πρόγονο του R, έστω Κ. Οπότε το $ε΄$ θα είναι βέλτιστο για το υποδέντρο με ρίζα Κ. Όμως $ε = max\{ ε_i\}$ με $ε_i$ όλα τα μονοπάτια που σχηματίζονται με ή χωρίς το R. 

### <u>Άσκηση 2: Μια συνάρτηση κόστους σε κατευθυνόμενα γραφήματα (DPV 3.25)</u>  

#### (α) Σε DAG

Έστω μια κορυφή u. 
Τότε όλες οι κορυφές που είναι προσπελάσιμος από τη $u$ είναι οι εξής:

- Η ίδια κορυφή $u$.
- Οι κορυφές με τις οποίες συνδέεται με ακμή $ u \rightarrow v_i: v_1, ... , v_d$ .
- Οι κορυφές που είναι προσπελάσιμες από τις κορυφές $ v_i$. 

Χρησιμοποιώντας αυτά τα δεδομένα υλοποιούμε τον αλγόριθμο που γεμίζει το γράφημα από τα φύλλα προς την ρίζα (αναδρομικά, ξεκινώντας από την ρίζα).
Κάθε κόμβος χαρακτηρίζεται 'Α' (ανεξερεύνητος) μέχρι να τον επισκεφθούμε, οπότε αλλάζει σε 'Ε' (εξερευνημένος). Ξεκινώντας από την ρίζα εκτελούμε αναδρομικά τον αλγόριθμο στους κόμβους παιδιά, μέχρι να φτάσουμε σε φύλλο. Τα φύλλα επιστρέφουν την τιμή τους και κάθε κόμβος επιστρέφει την μικρότερη τιμή που συνάντησε συμπεριλαμβανομένου και του εαυτού τους.

Παρακάτω ψευδοκώδικας για τον αλγόριθμο:

```c
for each u in V
	u.state = A
for each u in V
	if u.state = A
    	u.min = min_element(u)
        
min_element(node u)
	global_min = u
	for each kid k of u
		if k.state = A
			k.min = min_element(k)
		if global_min > k.min
			global_min = k.min
	return global_min
```

**Πολυπλοκότητα:** Γραμμική, $Ο(V+E)$,  αφού επισκεπτόμαστε κάθε κόμβο και ακμή μια φορά μόνο.
**Ορθότητα:** Όπως αναφέρθηκε παραπάνω όλες οι κορυφές που είναι προσπελάσιμος από τη u είναι οι εξής:

- Η ίδια κορυφή $u$.
- Οι κορυφές με τις οποίες συνδέεται με ακμή $ u \rightarrow v_i: v_1, ... , v_d$ .
- Οι κορυφές που είναι προσπελάσιμες από τις κορυφές $ v_i$, έστω $u_{i1},$ ... $,u_{in}$.

Με βάση αυτό ξεκινώντας από ένα κόμβο $u$ αναδρομικά φτάνουμε σε κάθε κόμβο προσπελάσιμο από αυτόν και τον χαρακτηρίζουμε εξερευνημένο (Ε). 
Έστω $k_i$ η τιμή που επιλέχθηκε από τον αλγόριθμό μας ($C$) για τον κόμβο $u$.
Έστω  $k_j$ η τιμή που επιλέχθηκε από έναν άλλο βέλτιστο αλγόριθμο για τον ίδιο κόμβο. Όμως $k_i = min \{u_1,$ ... , $u_d, u_{i1},$ ... $, u_{in}$ }. 
Άρα ισχύει: $k_j \geq k_i$.

#### (β) Εφαρμογή σε κάθε κατευθυνόμενο γράφημα.

Ο παραπάνω αλγόριθμος μπορεί να εφαρμοστεί σε κάθε κατευθυνόμενο γράφημα G χρησιμοποιώντας την έννοια των ΙΣΣ, μετατρέποντάς το δηλαδή σε DAG. 
Συνεπώς αρκεί να ορίσουμε τον αλγόριθμο που μετατρέπει ένα οποιοδήποτε κατευθυνόμενο γράφο σε DAG.

Παρακάτω ψευδοκώδικας για τον ζητούμενο αλγόριθμο:

```c
index = 0
S = empty array
for each vertex v in G do
      if (v.index is undefined) then
			strongconnect(v)
      end if
end for

function strongconnect(v)
      v.index = index
      v.lowlink = index
      index = index + 1
      S.push(v)
      v.onStack = true

      for each succesor w of v do
            if (w.index is undefined) then
                  strongconnect(w)
                  v.lowlink = min(v.lowlink, w.lowlink)
            else if (w.onStack) then
                  v.lowlink = min(v.lowlink, w.index)
            end if
      end for
      if (v.lowlink = v.index) then
            start a new strongly connected component
            repeat
                  w = S.pop()
                  w.onStack = false
                  add w to current strongly connected component
            while (w != v)
            output the current strongly connected component
      end if
end function
```

**Πολυπλοκότητα:** Ο αλγόριθμος αυτός καλείται μια φορά για κάθε κόμβο και εξετάζει κάθε ακμή το πολύ μια φορά. Άρα είναι γραμμικός ως προς τις ακμές και τους κόμβους του γράφου, δηλαδή: $Ο(V+E)$.
**Ορθότητα:**  ==fill dis==


### <u>Άσκηση 3: Κλέφτες και Αστυνόμοι</u>  



### <u>Άσκηση 4: Το Σύνολο των Συνδετικών Δέντρων (ΚΤ 4.27 και ΚΤ 4.28)</u>

#### (α)

Έστω $T_1, T_2$ δυο διαφορετικά συνδετικά δέντρα και $e \in T_2 \backslash  T_1$  με $(T_2 \backslash T_1) = \emptyset$/

- $Τ_1 \cup \{ e\}$  περιέχει κύκλο C. Υπάρχει ακμή $e' \in C, e' \notin T_2$ , αλλιώς το $Τ_2$ περιέχει τον C.
- $(Τ_1 \backslash \{e\}) \cup \{e'\}$ είναι άκυκλο με $n-1$ ακμές $\Rightarrow​$ Συνδετικό δέντρο.

Εύρεση $e'$. 
Έστω $T_1, T_2$ και $e = \{u, v\}$.

- Σε $Ο(|V|)$ κάνουμε DFS από το $u$ στο $v$ στο δέντρο $Τ_1$ και βρίσκουμε μονοπάτι $P$ που τους συνδέει.
- Για κάθε $e \in P$ ελέγχουμε σε $O(1)$ αν ανήκει στο $T_2$ και μόλις βρούμε $e \in P, e \notin T_2$ την αφαιρούμε. Συνολικά έχουμε $Ο(|V|)$.

### <u>Άσκηση 5: Μοναδικότητα Ελάχιστου Συνδετικού Δέντρου</u>  

 



